# Data Structure & Algorithm

## Data Structure
คือ หน่วยข้อมูลย่อย หรือ ประเภทข้อมูลที่ถูกจัดวางให้อยู่ในรูปแบบที่เหมาะสม โดยมีการนิยามความสัมพันธ์ภายในกลุ่มข้อมูลให้มีรูปแบบและข้อกำหนดที่ชัดเจน
### ประโยชน์
- ทำให้ข้อมูลมีระเบียบมากยิ่งขึ้น
- ส่งผลต่อประสิทธิภาพการทำงาน
### ประเภท
1. Linear Data Structures
   โครงสร้างข้อมูลที่สมาชิกแต่ละตัวจะเชื่อมกับสมาชิกตัวถัดไป**เพียงตัวเดียว** และ **มีลำดับต่อเนื่อง**
   - Array
   - Stack
   - Linked-List
   - Queue
2. Non-Linear Data Structures
    โครงสร้างที่ไม่มีคุณสมบัติของเชิงเส้น สามารถมช้แสดงความสัมพันธ์ของข้อมูลที่ซับซ้อนได้มากกว่า โดยข้อมูลหนึ่งตัว อาจมีความสัมพันธ์กับข้อมูลอื่น**ได้หลายตัว**
    - Tree
    - Graph

## Algorithm
คือ วิธีการแสดงลำดับขั้นตอนในการทำงานหรือขั้นตอนในการแก้ปัญหา

---

## การวัดประสิทธิภาพของ Algorithm
- Space Complexity Analysis
  เพื่อวัดขนาดข้อมูลที่ต้องการส่งเข้ามาประมวลผลแล้วไม่เกิดข้อผิดพลาด
  1. Instruction Space -> ความจำที่ต้องใช้ขณะคอมไฟล์
  2. Data Space -> ความจำที่ต้องใช้ในการเก็บข้อมูล
  3. Environment Stack Space -> ความจำที่ต้องใช้ในการเก็บผลลัพธ์
- Time Complexity Analysis
  เพื่อประมาณเวลาที่ใช้ในการประมวลผล
  1. Compile Time
  2. Runtime
### อัตราการเติบโตของฟังชัน
ใช้ในการบอกประสิทธิภาพความเร็วของ Algorithm
**ยิ่งโตช้า ยิ่งทำงานเร็ว BigO**

ขั้นตอนการวิเคราะห์
1. เขียน Algorithm
2. เลือกคำสั้่งตัวแทนที่ใช้
3. วิเคราะห์จำนวนครั้งที่คำสั่งทำงาน
4. หาฟังก์ชั่นของจำนวนครั้งที่คำสั่งทำงานกับปริมาณข้อมูล

> Ex. 1+2+3+...+n =?
> วิเคราะห์จากการหาแนวโน้ม
> - n=3 -> ต้องบวกทั้งหมด 2 ครั้ง
> - n=4 -> ต้องบวกทั้งหมด 3 ครั้ง
> - n=5 -> ต้องบวกทั้งหมด 4 ครั้ง
> 
> อนุมาณได้ว่า จำนวนครั้งที่ทำงานคือ n-1 ครั้ง
> 1. รูปแบบฟังก์ชั่น F(n-1) หรือ O(n-1)
> 2. เขียนแบบลดรูป O(n)
> 3. เรียกความเร็วแบบ O(n) ว่า **Linear Time Complexity**

สมการเปรียบเทียบการเติบโต
$$\lim_{n->\infty} \frac{f(n)}{g(n)}$$
- ถ้าได้ 0 แสดงว่า f(n) โตช้ากว่า
- ถ้าได้ $\infty$ แสดงว่า f(n) โตเร็วกว่า
- ถ้าได้ค่าคงที่ แสดงว่าโตเท่ากัน

> จะเรียงความเร็วBigOได้ดังนี้ 
> 1. O(1) Constant
> 2. O($log_n$) Logarithm
> 3. O(n) Linear
> 4. O($nlog_n$)  Linearithmic
> 5. O($n^2$) Quadratic
> 6. O($n^3$) Cubic
> 7. O($2^n$) Exponential
> 8. O($n!$)  Factorial

### การนับตัวดำเนินการ
การนับจำนวนครั้งการทำงานของตัวดำเนินการใน Algorithm
มี 4 รูปแบบ
1. แบบค่าคงที่ (Constant)
    พิจารณาจากจำนวนขั้นตอน O(1)
2. แบบลูปลำดับ (Linear Loop)
    พิจารณาจากจำนวนการทำงานภายในลูป 
    ```
    function sum(n=3){
      total = 0;  //1
      for (i=1; i<n; i++){  //n
        total += 1; //n-1
      }
    }
    ```
    $f(n) = 1+n+(n-1) = 2n -> O(2n) -> O(n)$
3. แบบลูปลอการิทึม (Logarithmic Loop)
   คล้ายกับลำดับแต่จะเพิ่มหรือคูณด้วยอัตราเท่าตัว
   ```
   function calcurate(){
    total = 0;  //1
    for (i=1; i<10; i=i*2){ //log2(n)+1
      //log2(n)
      //log2(n)
    }
   }
   ```
   $f(n) = 1+log_{2}n+1+log_{2}n+log_{2}n = 3log_{2}n+2 $ -> $ O(3log_{2}n+2)$ -> $O(log_2(n))$
4. แบบลูปซ้อน (Nested Loop)
    มีลักษณะเป็นลูปซ้อนลูป พิจารณาจากจำนวนลูปนอกและลูปใน
    ```
    total = 0;  //1
    for (i=0; i<n; i++){  //n+1
      for (j=0; j<n; j++){  //n(n+1)
        //n^2
        //n^2
      }
    }
    ```
    $f(n) = 1+(n+1)+n(n+1)+n^2+n^2 = 3n^2+2n+2$ -> $O(n^2)$

---

## Linked-List
จะเก็บข้อมูลลงในโหนด และนำข้อมูลแต่ละโหนดมาเรียงต่อกันเป็นลิสต์โดยใช้ **Link** หรือ **Pointer(Next)** เป็นตัวเชื่อมแต่ละโหนด
1. Singly Linked-List
    มีจุดเริ่มที่ Head ไปยังโหนดสุดท้ายที่ Tail โดยไม่สามารถทำงานย้อนกลับได้
2. Doubly Linked-List
    เหมือน Singly แต่ย้อนกลับได้

--- 

## Stack
จะเก็บข้อมูลในรูปแบบ **Last In, First Out(LIFO)** หรือก็คือ การนำเอาข้อมูลมาซ้อนกันเป็นชั้นๆไปเรื่อยๆ โดยเรียงจากล่างขึ้นบน สมาชิกที่อยู่บนสุดจะเรียกว่า **Top Stack**

---

## Queue
เป็นโครงสร้างข้อมูลที่มีการเก็บข้อมูลแบบลำดับ **First In, First Out(FIFO)**

---

## Tree 
เป็นโครงสร้างข้อมูลแบบ Non-Linear มีรูปแบบเหมือนกับแผนผังโครงสร้าง ที่มีความสัมพันธ์ด้านในเป็นลำดับชั้น โดยจะทำงานตั้งแต่ลำดับสูงสุดมาที่ลำดับล่างสุด ลำดับชั้นจะมีความสัมพันธ์ในรูปแบบ **Parent-Child** โดยจะถูกเชื่อมด้วย **Edge**

### Binary Tree
โครงสร้างข้อมูลแบบทรี แต่โหนดแม่จะมีลูกได้ไม่เกิน2โหนด
1. Full Binary Tree -> โหนดลูกต้องมีแค่2 หรือไม่มีเลย
2. Perfect Binary Tree -> โหนดที่อยู่ในระดับเดียวกันต้องมีขนาดเท่ากัน
3. Complete Binary Tree -> โหนดลำดับสุดท้ายสามารถมีลูกได้แค่1โหนด

### Binary Search Tree
- โหนดลูกที่มีค่าน้อยกว่าแม่จะอยู่ทางซ้าย
- โหนดลูกที่มีค่ามากกว่าแม่จะอยู่ทางขวา